*pick.txt*	Dynamic popup selection with fuzzy matching.

                                  by simirian

Overrides `vim.ui.select()` with a popup menu which provides fuzzy matching
and a string input. Also adds a variety of prebuilt pickers which can be
invoked through the `:Pick` command.

==============================================================================
Pick Command						*:Pick* *pick-command*

The `:Pick` command provided by this plugin gives access to the complete
functionality contained within. The command accepts one argument, which is the
name of the picker which is invoked. It will be one of the pickers listed in
|pick-pickers|. Using a `:Pick!` will cause the invoked picker to start with
the last input already entered for easy editing.

==============================================================================
Keymaps								*pick-keymaps*

The pick keymaps all start with `<leader>f` in an effort to make them easy to
use. The mnemonic for this keymap is "find", as in you are finding particular
entries from among a list. Every keymap is then followed by a mnemonic letter
(usually the first letter of the name) which invokes the picker. Using a
lowercase letter will open the picker with an empty prompt, using an uppercase
letter is the equivalent of using a bang in the command and will invoke the
picker with the last input for that type of picker.

==============================================================================
Pickers								*pick-pickers*

Several pickers are available for use through the |pick-keymaps| and the
`:Pick` command. They are shown in the table below, where "name" is the name
by which they can be invoked with the command, "keymap" is the keymap which
invokes the default picker, "input method" is the type of input used to select
entries from the list, and "picks over" is a description of the items which
will be available in the list.

name	keymap	input method	picks over ~
grep	fg	raw ripgrep	grep in the current directory
help	fh	|pick-fuzz|	help tags in rtp `doc/` directories
files	ff	|pick-fuzz|	child files (ignores `.git/`)
buffers	fb	|pick-fuzz|	buffer names in `:ls`

The following pickers are planned for future releases:

- quickfix list entries
- location list entries
- character selector (emoji, unicode, nerdfonts)

==============================================================================
Fuzzy Finding							*pick-fuzz*

Fizzy finding using this module has special input semantics based on prefixes
to search terms. A leading space at the start of a fuzzy search query will be
ignored and force fuzzy matching with the rest of the string, so if you want
to search with a prefix character you are able to.

Starting a query with one of an apostrophe "'", a caret "^", or a dollar sign
"$" will search for the following |lua-pattern| in, at the start of, or at the
end of each item in the list. Further prefixing with a bang "!" will negate
the pattern matching, so only entries which do not match will be shown and
selectable. The prefixes are summarised in the table below.

prefix	meaning ~
'	the query is a lua pattern
!'	the query is a lua pattern which is not in the target
^	the query is a lua pattern that the target starts with
!^	the query is a lua pattern that the target does not start with
$	the query is a lua pattern that the target ends with
!$	the query is a lua pattern that the target does not end with
<space>	the query is a fuzzy-matching pattern

In all cases, the entire prefix is stripped from the start of the query when
the query is used for matching. This means that " 'spe" will do a fuzzy search
for the term "'spe", which will probably find the 'spell' option in the help
picker. If a query starts with a bang but does not match one of the prefixes
above, the bang is included in a fuzzy match over the entire input. This means
that "!file" will search over that entire term.

The particular fuzzy finding algorithm is something I threw together in a few
hours based on a brief description from a bioinformatics class I took months
ago. This means it's probably not the best. It's still pretty good though! And
it's a fuzzy-matching algorithm, so it doesn't really matter, now does it?

 vim:tw=78:ts=8:noet:ft=help:norl:
