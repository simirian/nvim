*pick.txt*	Dynamic popup selection with fuzzy matching.

                                  by simirian

Overrides `vim.ui.select()` with a popup menu which provides fuzzy matching
and a string input. Also adds a variety of prebuilt pickers which can be
invoked through the `:Pick` command.

==============================================================================
Pick Command						*:Pick* *pick-command*

The `:Pick` command provided by this plugin gives access to the complete
functionality contained within. The command accepts one argument, which is the
name of the picker which is invoked. It will be one of the pickers listed in
|pick-pickers|. Using a `:Pick!` will cause the invoked picker to start with
the last input already entered for easy editing.

==============================================================================
Keymaps								*pick-keymaps*

The pick keymaps all start with `<leader>f` in an effort to make them easy to
use. The mnemonic for this keymap is "find", as in you are finding particular
entries from among a list. Every keymap is then followed by a mnemonic letter
(usually the first letter of the name) which invokes the picker. Using a
lowercase letter will open the picker with an empty prompt, using an uppercase
letter is the equivalent of using a bang in the command and will invoke the
picker with the last input for that type of picker.

==============================================================================
Pickers								*pick-pickers*

Several pickers are available for use through the |pick-keymaps| and the
`:Pick` command. They are shown in the table below, where "name" is the name
by which they can be invoked with the command, "keymap" is the keymap which
invokes the default picker, "input method" is the type of input used to select
entries from the list, and "picks over" is a description of the items which
will be available in the list.

name	keymap	input method	picks over ~
grep	fg	raw ripgrep	grep in the current directory
help	fh	|pick-fuzz|	help tags in rtp `doc/` directories
files	ff	|pick-fuzz|	child files (ignores `.git/`)
buffers	fb	|pick-fuzz|	buffer names in `:ls`

The following pickers are planned for future releases:

- quickfix list entries
- location list entries
- character selector (emoji, unicode, nerdfonts)

==============================================================================
Fuzzy Finding							*pick-fuzz*

Fizzy finding using this module has special input semantics based on prefixes
to search terms. A leading space at the start of a fuzzy search query will be
ignored and force fuzzy matching with the rest of the string, so if you want
to search with a prefix character you are able to.

Starting a query with one of an apostrophe "'", a caret "^", or a dollar sign
"$" will search for the following |lua-pattern| in, at the start of, or at the
end of each item in the list. Further prefixing with a bang "!" will negate
the pattern matching, so only entries which do not match will be shown and
selectable. The prefixes are summarised in the table below.

prefix	meaning ~
'	contains lua pattern
!'	does not contain lua pattern
^	starts with lua pattern
!^	does not start with lua pattern
$	ends with lua pattern
!$	does not end with lua pattern
<space>	force fuzzy matching

In all cases, the entire prefix is stripped from the start of the query when
the query is used for matching. This means that " 'spe" will do a fuzzy search
for the term "'spe", which will probably find the 'spell' option in the help
picker. If a query starts with a bang but does not match one of the prefixes
above, the bang is included in a fuzzy match over the entire input. This means
that "!file" will search over that entire term.

The particular fuzzy finding algorithm is something I threw together in a day
based on half-baked ideas and some non-representative testing. There are a few
major features to consider to maximize use of the fuzzy algorithm. The first
is that it REALLY cares about how much of the query is in the test string.
Even if you match 3/4 of a query, there is a good chance that the entry
will not show up. The algorithm also does not skip characters in a query. If a
query has a mistyped "q" in the middle, it will almost always fail on every
test string.

Other than those particulars, the algorithm uses a few very simple rules. The
closer matching characters are to each other the stronger the match will be,
and the closer they are to the start of the test string the stronger the match
as well. The algorithm will prefer accurate letter case, but will still accept
characters whose case differs in the query and the test string. If a query
matches most of a test string, then it will also perform better.

This algorithm is absolutely not perfect. The mistyped "q" example above could
be regarded as a bug, but this is a fuzzy matching system so there aren't
really any rules anyways. If your query doesn't match what you want it to,
then just try with a different query?

 vim:tw=78:ts=8:noet:ft=help:norl:
