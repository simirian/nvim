--- simirian's Neovim
--- generic picker plugin

--- @class Picker<T>
local Picker = {}

Picker.__index = Picker

--- Creates a new picker from a table.
--- @param tbl table The table to turn into a picker.
--- @return Picker picker The new picker
function Picker.new(tbl)
  return setmetatable(tbl, Picker)
end

--- Generates the initial list for the picker to select out of.
--- @generic T
--- @return T[] items The generated items.
function Picker:generate()
  return {}
end

--- Sorts the list that was generated.
--- @generic T
--- @param items T[] The list of items to sort.
--- @param prompt string The user prompt to use for sorting.
--- @return T[] items The sorted items
function Picker:sort(items, prompt)
  return items
end

--- Called to display each item which is shown in the list.
--- @generic T
--- @param item T The item to display.
--- @param idx integer The index of the number.
--- @return string str The item as a string.
function Picker:display(item, idx)
  return tostring(item)
end

--- Called when an item in the list is selected.
--- @generic T
--- @param item T The item that was selected.
--- @param idx integer The index of the item.
function Picker:confirm(item, idx)
  vim.print(item)
end

--- @type Picker
local bound

--- The list of items which were generated by the bound picker.
--- @type any[]
local generated

--- The list of items which were sorted by the bound picker.
--- @type any[]
local sorted

--- The index of the selected item.
--- @type integer
local selected

--- Buffer used for input.
--- @type integer
local ibuf = vim.api.nvim_create_buf(false, true)
vim.api.nvim_buf_set_name(ibuf, "Pick Input")

--- Buffer used for listing.
--- @type integer
local lbuf = vim.api.nvim_create_buf(false, true)
vim.api.nvim_buf_set_name(lbuf, "Pick List")

--- Easy to use defaults for creating a window config.
--- @param opts vim.api.keyset.win_config Window config overrides.
--- @return vim.api.keyset.win_config
local function winconfig(opts)
  return vim.tbl_deep_extend("force", {
    relative = "editor",
    row = 0,
    col = 0,
    height = 1,
    width = 1,
    border = "solid",
    style = "minimal",
  }, opts)
end

--- The window used to display the input buffer.
--- @type integer
local iwin = vim.api.nvim_open_win(ibuf, false, winconfig({ hide = true }))

--- The window used to display the list buffer.
--- @type integer
local lwin = vim.api.nvim_open_win(lbuf, false, winconfig({ hide = true }))

--- @type integer?
local oldwin

--- Opens the picker windows.
local function openwins()
  vim.api.nvim_win_set_config(iwin, winconfig({
    row = math.floor(vim.o.lines / 10),
    col = math.floor(vim.o.columns / 10),
    height = 1,
    width = math.floor(vim.o.columns * 8 / 10),
    hide = false,
  }))
  vim.wo[iwin].winhighlight = "NormalFloat:PickInput,FloatBorder:PickInput"
  vim.wo[iwin].statuscolumn = "%#PickInput# Ôê¢  "
  vim.api.nvim_win_set_config(lwin, winconfig({
    row = math.floor(vim.o.lines / 10 + 3),
    col = math.floor(vim.o.columns / 10),
    width = math.floor(vim.o.columns * 8 / 10),
    height = math.floor(vim.o.lines * 8 / 10 - 5),
    hide = false,
  }))
  vim.wo[lwin].cursorline = true
  vim.wo[lwin].winhighlight = "NormalFloat:PickList,FloatBorder:PickList,CursorLine:Search"
  vim.api.nvim_set_current_win(iwin)
end

--- Closes the picker windows.
local function closewins()
  vim.api.nvim_win_set_config(iwin, winconfig({ hide = true }))
  vim.api.nvim_win_set_config(lwin, winconfig({ hide = true }))
  vim.api.nvim_set_current_win(oldwin or vim.api.nvim_tabpage_list_wins(0)[1])
  vim.api.nvim_buf_set_lines(ibuf, 0, -1, false, {""})
end

--- Renders only the lines which could be visible, instead of all lines.
local function displayframe()
  local winheight = vim.api.nvim_win_get_height(lwin)
  local first = math.max(selected - winheight, 1)
  local last = math.min(selected + winheight, #sorted)
  local lines = vim.api.nvim_buf_get_lines(lbuf, first - 1, last, false)
  for i = first, last do
    if lines[i] == "" then
      lines[i] = bound:display(sorted[i], i)
    end
  end
  vim.bo[lbuf].modifiable = true
  vim.api.nvim_buf_set_lines(lbuf, first - 1, last, false, lines)
  vim.bo[lbuf].modifiable = false
  vim.api.nvim_win_set_cursor(lwin, { selected, 0 })
end

--- Runs the picker sorter on the generated items.
local function sort()
  local line = vim.api.nvim_buf_get_lines(ibuf, -2, -1, false)[1]
  sorted = bound:sort(generated, line)
  selected = 1
  vim.bo[lbuf].modifiable = true
  vim.api.nvim_buf_set_lines(lbuf, 0, -1, false,
    vim.tbl_map(function() return "" end, sorted))
  vim.bo[lbuf].modifiable = false
  displayframe()
end

--- Runs a picker.
--- @param picker Picker<any> The picker to run.
local function run(picker)
  openwins()
  bound = picker
  generated = bound:generate()
  sort()
end

--- The auroup used by this plugin.
--- @type integer
local augroup = vim.api.nvim_create_augroup("pick", { clear = true })

vim.api.nvim_create_autocmd({ "TextChangedI", "TextChanged" }, {
  desc = "Update picker item list.",
  group = augroup,
  buffer = ibuf,
  callback = sort,
})

vim.api.nvim_create_autocmd("BufEnter", {
  desc = "Enter insert mode when entering the input buffer.",
  group = augroup,
  buffer = ibuf,
  callback = function()
    vim.cmd.startinsert()
    vim.api.nvim_win_set_cursor(0, {
      vim.api.nvim_win_get_cursor(0)[1],
      #vim.api.nvim_get_current_line()
    })
  end,
})

vim.api.nvim_create_autocmd("BufLeave", {
  desc = "Close picker when leaving the input buffer.",
  group = augroup,
  buffer = ibuf,
  callback = function()
    closewins()
    vim.cmd.stopinsert()
  end,
})

vim.keymap.set({ "i", "n" }, "<cr>", function()
  closewins()
  bound:confirm(sorted[selected], selected)
end, { desc = "Confirm picker selection.", buffer = ibuf })

vim.keymap.set("n", "<esc>", function()
  closewins()
end, { desc = "Close the picker.", buffer = ibuf })

vim.keymap.set({ "i", "n" }, "<C-n>", function()
  selected = selected == #sorted and 1 or selected + 1
  displayframe()
end, { desc = "Select next item in list.", buffer = ibuf })

vim.keymap.set({ "i", "n" }, "<C-p>", function()
  selected = selected == 1 and #sorted or selected - 1
  displayframe()
end, { desc = "Select previous item in list.", buffer = ibuf })

--- Scores a string based on how well it matches a query. UPDATED! I wrote the
--- new version in an hour as well, but after taking a bioinformatics class and
--- learning about sequence alignment :P This is slower: O(NM), but still likely
--- fast enough most people.
--- @param item string The item to score.
--- @param query string The query to score based on.
local function score(item, query)
  local match = 1 -- initial match
  local continue = 1.5 -- subsequent matches
  local mismatch = -1.2 -- mismatched query and item
  local startskip = -0.1 -- skipped start of item
  local strskip = -.5 -- skipped middle part of item
  local skipmore = -.6 -- skipped subsequent middle parts of item
  local endskip = -0.03 -- skipped terminal part of item
  local qryskip = -1 -- skipped query character
  local qryfail = -2 -- failed to complete query

  local skiptype = 0
  local matchtype = 1
  local notype = 2

  local sl = #item
  local ql = #query

  local scores = { { 0 } }
  local types = { { 2 } }

  for col = 2, sl + 1 do
    scores[1][col] = scores[1][col - 1] + startskip
    types[1][col] = skiptype
  end

  for row = 2, ql + 1 do
    local psrow = scores[row - 1]
    local ptrow = types[row - 1]
    local srow = { psrow[1] + qryskip }
    local trow = { notype }
    for col = 2, sl + 1 do
      -- score coming from above
      local s = psrow[col] + (col == sl and qryfail or qryskip)
      local t = notype

      -- score coming from left
      local ls = srow[col - 1]
      if row == ql + 1 then
        ls = ls + endskip
      elseif trow[col - 1] == skiptype then
        ls = ls + skipmore
      else
        ls = ls + strskip
      end
      if ls > s then
        s = ls
        t = skiptype
      end

      -- score coming from the diagonal
      local ds = psrow[col - 1]
      local m = item:sub(col - 1, col - 1) == query:sub(row - 1, row - 1)
      if not m then
        ds = ds + mismatch
      elseif ptrow[col - 1] == matchtype then
        ds = ds + continue
      else
        ds = ds + match
      end
      if ds > s then
        s = ds
        t = m and matchtype or notype
      end

      srow[col] = s
      trow[col] = t
    end
    scores[row] = srow
    types[row] = trow
  end
  return scores[ql + 1][sl + 1]
end

--- Simple fuzzy finding algorithm.
--- @param list string[] List of strings to score.
--- @param query string The query string to score based on.
--- @return string[]
local function fuzz(list, query)
  local plist = {}
  local itemsn = 1
  for _, e in ipairs(list) do
    local s = score(e, query)
    if s > 0 then
      plist[itemsn] = { e, s }
      itemsn = itemsn + 1
    end
  end
  table.sort(plist, function(a, b)
    return a[2] > b[2]
  end)
  return vim.tbl_map(function(e) return e[1] end, plist)
end

--- Filters/sorts selections based on mini.nvim's pick module, but also forces
--- fuzzy matching if the first character is a space, and ignores that space.
--- Uses the above fuzz() function as a fallback for when there isn't a prefix.
--- @param list string[] The list to be filtered.
--- @param query string The query to use to filter the list.
--- @return string[]
local function match(list, query)
  local function pmatch(s, q)
    local ok, found = pcall(string.match, s, q)
    return ok and found ~= nil
  end
  if query == "" then return list end
  local neg = query:sub(1, 1) == "!"
  local mode = neg and query:sub(2, 2) or query:sub(1, 1)
  local predicates = {
    ["'"] = function(e) return pmatch(e, query) ~= neg end,
    ["^"] = function(e) return pmatch(e, "^" .. query) ~= neg end,
    ["$"] = function(e) return pmatch(e, query .. "$") ~= neg end,
  }
  if predicates[mode] then
    query = query:sub(neg and 3 or 2)
    return vim.tbl_filter(predicates[mode], list)
  else
    if query:sub(1, 1) == " " then
      return fuzz(list, query:sub(2))
    else
      return fuzz(list, query)
    end
  end
end

local pickers = {}

--- @class Pick.Select<T>: Picker
pickers.select = Picker.new({
  --- Callback for choosing an item.
  --- @generic T
  --- @param item T
  --- @param idx integer
  on_choice = function(item, idx) end,

  --- Fucntion to format items.
  --- @generic T
  --- @param item T
  --- @return string
  format_item = function(item) return "" end,

  --- @generic T
  --- @type T
  list = nil,
})

--- Generates the initial list for the picker to select out of.
--- @generic T
--- @return T[] items The generated items.
function pickers.select:generate()
  return self.list
end

function pickers.select:sort(items, prompt)
  if self.format_item then
    return match(vim.tbl_map(self.format_item, items), prompt)
  else
    return match(vim.tbl_map(tostring, items), prompt)
  end
end

function pickers.select:display(item)
  if self.format_item then
    return self.format_item(item)
  else
    return tostring(item)
  end
end

function pickers.select:confirm(item, idx)
  self.on_choice(item, idx)
end

--- Prompt user to select an item from a list.
--- @generic T
--- @param list T[]
--- @param opts { format_item?: fun(item: T): string }
--- @param on_choice fun(item: T, idx: integer)
--- @diagnostic disable-next-line: duplicate-set-field
vim.ui.select = function(list, opts, on_choice)
  pickers.select.list = list
  pickers.select.format_item = opts.format_item
  pickers.select.on_choice = on_choice
  run(pickers.select)
end

--- @class Pick.Grep: Picker
pickers.grep = Picker.new({
  --- @type string[]
  items = nil,
})

--- Generates items for the picker. This happens here because we generate based
--- on the prompt with grep.
--- @param prompt string
--- @return string[]
function pickers.grep:sort(_, prompt)
  local result = vim.system(
    { "rg", "--vimgrep", "-Se", prompt == "" and ".*" or prompt },
    {}, function() end):wait()
  if result.code == 0 then
    local new = vim.split(result.stdout, "[\r\n]+", { trimempty = true })
    self.items = new
    return new
  else
    if not self.items then
      error("grep failed with no backup items\n" .. result.stderr)
    end
    return self.items
  end
end

--- Jumps to the selected item's location.
--- @param item string
function pickers.grep:confirm(item)
  local name, line, col = item:match("^([^:]+):(%d+):(%d+):.*$")
  if name and line and col then
    vim.cmd.edit(name)
    vim.api.nvim_win_set_cursor(0, { tonumber(line), tonumber(col) })
  end
  self.items = nil
end

--- @class Pick.Help: Picker
pickers.help = Picker.new({
  --- @type string[]
  tags = nil,
})

--- Generates and caches a list of all of the help tags that currently exist.
--- @return string[]
function pickers.help:generate()
  if self.tags then return self.tags end
  local tags = {}
  local files = vim.api.nvim_get_runtime_file("doc/tags", true)
  for _, file in ipairs(files) do
    --- @diagnostic disable: undefined-field
    local fd = vim.uv.fs_open(file, "r", 420)
    local size = vim.uv.fs_fstat(fd).size
    local contents = vim.uv.fs_read(fd, size)
    vim.uv.fs_close(fd)
    --- @diagnostic enable: undefined-field
    for _, line in ipairs(vim.split(contents, "[\r\n]+", { trimempty = true })) do
      local tag = line:match("^[^\t]+")
      table.insert(tags, tag)
    end
  end
  self.tags = tags
  return tags
end

--- Fuzzy matches the help tags.
--- @param items string[]
--- @param prompt string
--- @return string[]
function pickers.help:sort(items, prompt)
  return match(items, prompt)
end

--- Opens the tag with :help.
--- @param item string
function pickers.help:confirm(item)
  vim.cmd.help(item)
end

--- @class Pick.Files: Picker
pickers.files = Picker.new({
  --- @type string[]
  paths = nil,

  --- @type string
  cachedir = nil,
})

--- Caches all files in the current directory
--- @return string[]
function pickers.files:generate()
  if self.paths then return self.paths end
  local function lsr(dir)
    local strs = {}
    for name, type in vim.fs.dir(dir) do
      if name ~= ".git" or type ~= "directory" then
        local fname = dir .. "/" .. name
        table.insert(strs, fname)
        if type == "directory" then
          vim.list_extend(strs, lsr(fname))
        end
      end
    end
    return strs
  end
  --- @diagnostic disable-next-line: undefined-field
  self.cachedir = vim.fs.normalize(vim.uv.cwd())
  self.paths = lsr(self.cachedir)
  self.paths = vim.tbl_map(function(e)
    return e:sub(#self.cachedir + 2)
  end, self.paths)
  return self.paths
end

--- Uses fuzzy matching to sort the files based on the user prompt.
--- @param items string[]
--- @param prompt string
--- @return string[]
function pickers.files:sort(items, prompt)
  return match(items, prompt)
end

--- Edits the selected file
--- @param item string
function pickers.files:confirm(item)
  vim.cmd.edit(item)
end

vim.api.nvim_create_user_command("Pick", function(args)
  pickers[args.args](args.bang)
end, {
  desc = "Use a picker.",
  nargs = "?",
  bang = true,
  complete = function(arglead, cmdline, curpos)
    if curpos ~= #cmdline then return end
    return vim.tbl_filter(function(e)
      return vim.startswith(e, arglead)
    end, vim.tbl_keys(pickers))
  end,
})

vim.keymap.set("n", "<leader>ff", function() run(pickers.files) end, { desc = "Find files." })
vim.keymap.set("n", "<leader>fh", function() run(pickers.help) end, { desc = "Find help." })
vim.keymap.set("n", "<leader>fg", function() run(pickers.grep) end, { desc = "Find with grep." })
